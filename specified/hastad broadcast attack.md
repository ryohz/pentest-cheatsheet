#rsa
#crypto

同一の平文mを異なるnで暗号化した暗号文がe個判明しているときに使える攻撃
中国剰余定理を利用している。
available attack when $e$ cipher is known what is generated with `e` same plaintexts and `e` different `n`
```python
from gmpy2 import invert,iroot as ir
import sys
from Crypto.Util.number import long_to_bytes

c1 = "redacted"
c2 = "redacted"
c3 = "redacted"
n1 = "redacted"
n2 = "redacted"
n3 = "redacted"
e = 3

def mlt_any(lst):
    r = 1
    for i in range(len(lst)):
        r *= lst[i]
    return r


def crt(N,C):
    # N = [n1,n2,n3, .... ,ne]
    # C = [c1,c2,c3, .... ,ce]
    try:
        assert len(N) == len(C)
    except AssertionError:
        print("Error: N and C must have the same length")
        sys.exit(1)

    try:
        assert len(N) >= e
    except AssertionError:
        print("Error: number of pairs (n,c) must be same as e")
        sys.exit(1)

    N = N[0:e]
    C = C[0:e]

    mlta = mlt_any(N)

    print("modulo:", mlta)
    total = 0
    for (ni,ci) in zip(N,C):
        p = mlta // ni
        total += ci * invert(p,ni) * p

    return total % mlta

def iroot(x):
    m,is_valid = ir(x,e)
    if is_valid:
        print("plain text: ",long_to_bytes(m))
    else:
        print("couldn't find any plain text")

def main():
    C = [c1,c2,c3]
    N = [n1,n2,n3]
    x = crt(N,C)
    iroot(x)


if __name__ == "__main__":
    main()
```